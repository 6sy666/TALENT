**num_embeddings**
===============================================

A set of functions to compute and validate bin edges for numerical feature discretization, commonly used in embeddings like piecewise linear encoding.


**Bin Validation**
------------------

.. code-block:: python

    def _check_bins(bins: List[Tensor]) -> None

Validates the structure of bin edges to ensure they meet requirements for discretization.

**Parameters:**
* **bins** *(List[Tensor])* - List of tensors, where each tensor contains bin edges for a feature.

**Raises:**
* **ValueError** - If bins are empty, not 1D tensors, have fewer than 2 edges, contain non-finite values, or are unsorted.
* **UserWarning** - If a feature has exactly 2 bin edges (only 1 bin, equivalent to MinMax scaling).


**Bin Edge Calculation**
------------------------

.. code-block:: python

    def compute_bins(
        X: torch.Tensor,
        n_bins: int = 48,
        *,
        tree_kwargs: Optional[Dict[str, Any]] = None,
        y: Optional[Tensor] = None,
        regression: Optional[bool] = None,
        verbose: bool = False,
    ) -> List[Tensor]

Computes bin edges for numerical features using either quantile-based or tree-based methods.

**Parameters:**
* **X** *(torch.Tensor)* - 2D tensor of shape `(n_samples, n_features)` containing numerical features.
* **n_bins** *(int, optional, Default is 48)* - Target number of bins (actual count may vary).
* **tree_kwargs** *(Optional[Dict[str, Any]])* - If provided, uses tree-based binning with these kwargs for the decision tree.
* **y** *(Optional[Tensor])* - 1D tensor of labels (required for tree-based binning).
* **regression** *(Optional[bool])* - Whether the task is regression (required for tree-based binning).
* **verbose** *(bool, optional, Default is False)* - If True, uses `tqdm` to show progress for tree-based binning.

**Returns:**
* **List[Tensor]** - List of tensors, where each tensor contains sorted, unique bin edges for a feature, with shape `(n_edges,)`.


**Behavior Details**
--------------------

1. **Quantile-Based Binning (default, `tree_kwargs=None`)**:
   - Computes bin edges as quantiles of the feature distribution.
   - Uses `torch.quantile` with `n_bins + 1` quantiles (from 0.0 to 1.0).
   - Removes duplicate edges to ensure uniqueness.
   - Validates edges with `_check_bins`.


2. **Tree-Based Binning (`tree_kwargs` provided)**:
   - Uses scikit-learn decision trees to find split points based on label information.
   - Fits a separate tree for each feature (regression or classification, based on `regression`).
   - Collects split thresholds from tree nodes as potential bin edges.
   - Includes min/max of the feature as edge boundaries.
   - Removes duplicates and sorts edges.
   - Validates edges with `_check_bins` and returns them on the same device/dtype as `X`.


**Constraints and Requirements**
---------------------------------
- `X` must be a 2D PyTorch tensor with finite values and at least 2 distinct values per feature.
- `n_bins` must be between 2 and `len(X) - 1`.
- For tree-based binning:
  - `y` (labels) and `regression` (task type) must be provided.
  - `tree_kwargs` must not contain `max_leaf_nodes` (automatically set to `n_bins`).
  - Scikit-learn must be installed (raises `RuntimeError` otherwise).
  - `tqdm` is required for verbose progress (raises `ImportError` if missing).


**Example Use Cases**
---------------------
- Preprocessing numerical features for piecewise linear embeddings.
- Discretizing features for tabular deep learning models.
- Supervised binning to align splits with label patterns (tree-based method).

.. code-block:: python

    class _PiecewiseLinearEncodingImpl(nn.Module)

Internal implementation of piecewise linear encoding (not recommended for direct use, as outputs contain infinite values).

**Parameters**
^^^^^^^^^^^^^^
- **bins** *(List[Tensor])*: List of 1D tensors, where each tensor represents bin edges for a feature (generated by `compute_bins`).


**Attributes**
^^^^^^^^^^^^^^
- **edges** *(Tensor)*: Tensor of bin edges with shape `(n_features, max_n_edges - 1)`, padded with `inf` for uniform shape.
- **width** *(Tensor)*: Tensor of bin widths with the same shape as `edges` (computed as edge differences).
- **mask** *(Tensor)*: Boolean mask tensor with the same shape as `edges`, marking valid bins (non-padded regions).
- **_bin_counts** *(Tuple[int])*: Number of bins per feature (`len(bins[i]) - 1`).
- **_same_bin_count** *(bool)*: Flag indicating if all features have the same number of bins.


.. code-block:: python

    def forward(self, x: Tensor) -> Tensor

Computes piecewise linear encoding for input features.

**Parameters**

**x** (*Tensor*)
    Input tensor with shape ``(*batch_dims, n_features)`` (at least 2-D).

**Returns**

**Tensor**
    Encoded tensor with shape ``(*batch_dims, n_features, max_n_bins)``,
    where ``max_n_bins`` is the maximum number of bins across all features.


class PiecewiseLinearEncoding(nn.Module)
----------------------------------------

Wrapper for ``_PiecewiseLinearEncodingImpl`` that sanitizes outputs
(removes infinite values).

**Parameters**

**bins** (*List[Tensor]*)
    List of 1-D tensors, where each tensor represents the bin edges for a
    feature .



.. code-block:: python

    def forward(self, x: Tensor) -> Tensor

Computes piecewise linear encoding with cleaned outputs.

**Parameters**

**x** (*Tensor*)
    Input tensor with shape ``(*batch_dims, n_features)`` (at least 2-D).

**Returns**

**Tensor**
    Encoded tensor:

    - If all features have the same number of bins:
      shape ``(*batch_dims, n_features * n_bins)`` (flattened last two dimensions).

    - If bin counts vary:
      shape ``(*batch_dims, total_valid_bins)`` (filtered via mask to remove padding).

      **Unary Encoding**
------------------

### Internal Implementation Class

.. code-block:: python

    class _UnaryEncodingImpl(nn.Module)

Internal implementation of unary encoding, converting feature values into binary indicators of bin membership.

**Parameters**
^^^^^^^^^^^^^^
- **bins** *(List[Tensor])*: List of 1D tensors, where each tensor represents bin edges for a feature (generated by `compute_bins`).


**Attributes**

- **edges** *(Tensor)*: Tensor of bin edges with shape `(n_features, max_n_edges - 1)`, padded with `inf` for uniform shape.
- **mask** *(Tensor)*: Boolean mask tensor with the same shape as `edges`, marking valid bins (non-padded regions).
- **_bin_counts** *(Tuple[int])*: Number of bins per feature (`len(bins[i]) - 1`).
- **_same_bin_count** *(bool)*: Flag indicating if all features have the same number of bins.


**Forward Method**


.. code-block:: python

    def forward(self, x: Tensor) -> Tensor

Computes unary encoding for input features.

**Parameters**

- **x** *(Tensor)*: Input tensor with shape `(*batch_dims, n_features)` (at least 2D).

**Returns**

- **Tensor**: Encoded tensor with shape `(*batch_dims, n_features, max_n_bins)`, where `max_n_bins` is the maximum number of bins across all features. Values are in `[0, 1]`.
